Programming Essentials in Python: Module 2
In this module, you will learn about:
1.data types and the basic methods of formatting, converting, inputting and outputting data;
2.operators;
3.variables.
_____________________________________________________________________________________________________

Hello, World!
It's time to start writing some real, working Python code. It'll be very simple for the time being
As we're going to show you some fundamental concepts and terms, these snippets of code won't 
be serious or complex.
print("Hello World")
Copy and run the code in https://repl.it/repls/PaltryBothOpen64#main.py 
Alternatively, launch IDLE, create a new Python source file, fill it with this code, name the 
file and save it. Now run it. If everything goes okay, you'll see the rhyme's line in the IDLE 
console window. The code you have run should look familiar. You saw something very similar when we 
led you through the setting up of the IDLE environment.
Now we'll spend some time showing and explaining to you what you're actually seeing, and why it 
looks like this.
As you can see, the first program consists of the following parts:
1.the word print;
2.an opening parenthesis;
3.a quotation mark;
4.a line of text: Hello, World!;
5.another quotation mark;
6.a closing parenthesis.
Each of the above plays a very important role in the code.

_____________________________________________________________________________________________________
The print() function
Look at the line of code below:
print("Hello, World!")
The word print that you can see here is a function name. That doesn't mean that wherever the word 
appears it is always a function name. The meaning of the word comes from the context in which the word 
has been used.
You've probably encountered the term function many times before, during math classes. 
You can probably also list several names of mathematical functions, like sine or log.
Python's functions, however, are more flexible, and can contain more content than their 
mathematical siblings.
A function (in this context) is a separate part of the computer code able to:
1.cause some effect (e.g., send text to the terminal, create a file, draw an image, play a sound, etc.); 
this is something completely unheard of in the world of mathematics;
2.evaluate a value or some values (e.g., the square root of a value or the length of a given text); 
this is what makes Python's functions the relatives of mathematical concepts.
Moreover, many of Python's functions can do the above two things togethe
Where do the functions come from?
1.They may come from Python itself; the print function is one of this kind; such a function is an 
added value received together with Python and its environment (it is built-in); you don't have to do 
anything special (e.g., ask anyone for anything) if you want to make use of it;
2.they may come from one or more of Python's add-ons named modules; some of the modules come with Python, 
others may require separate installation - whatever the case, they all need to be explicitly connected with 
your code (we'll show you how to do that soon);
3.you can write them yourself, placing as many functions as you want and need inside your program to 
make it simpler, clearer and more elegant.
The name of the function should be significant (the name of the print function is self-evident).
Of course, if you're going to make use of any already existing function, 
you have no influence on its name, but when you start writing your own functions, 
you should consider carefully your choice of names.
_____________________________________________________________________________________________________
The print() function
As we said before, a function may have:
an effect;
a result
There's also a third, very important, function component - the argument(s).
Mathematical functions usually take one argument, e.g., sin(x) takes an x, which is the 
measure of an angle.
Python functions, on the other hand, are more versatile. Depending on the individual needs, 
they may accept any number of arguments - as many as necessary to perform their tasks. Note: any 
number includes zero - some Python functions don't need any argument.
print("Hello, World!")
In spite of the number of needed/provided arguments, Python functions strongly demand the 
presence of a pair of parentheses - opening and closing ones, respectively.
If you want to deliver one or more arguments to a function, you place them inside the parentheses. 
If you're going to use a function which doesn't take any argument, you still have to have the parentheses
Note: to distinguish ordinary words from function names, place a pair of empty parentheses after their 
names, even if the corresponding function wants one or more arguments. This is a standard convention.
The function we're talking about here is print().
Does the print() function in our example have any arguments?
Of course it does, but what are they?
_______________________________________________________________________________________________________
The print() function
The only argument delivered to the print() function in this example is a string:
print("Hello, World!")
As you can see, the string is delimited with quotes - in fact, the quotes make the string - they 
cut out a part of the code and assign a different meaning to it.
You can imagine that the quotes say something like: the text between us is not code. It isn't 
intended to be executed, and you should take it as is.
Almost anything you put inside the quotes will be taken literally, not as code, but as data. Try to 
play with this particular string - modify it, enter some new content, delete some of the existing content.
There's more than one way to specify a string inside Python's code, but for now, though, this one is enough
So far, you have learned about two important parts of the code: the function and the string. We've talked 
about them in terms of syntax, but now it's time to discuss them in terms of semantics
_____________________________________________________________________________________________________

The print() functio
The function name (print in this case) along with the parentheses and argument(s), 
forms the function invocation.
We'll discuss this in more depth soon, but we should just shed a little light on it right now
print("Hello, World!")
What happens when Python encounters an invocation like this one below?
function_name(argument)
Let's see:
1.First, Python checks if the name specified is legal (it browses its internal data in order 
to find an existing function of the name; if this search fails, Python aborts the code);
2.second, Python checks if the function's requirements for the number of arguments allows 
you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, 
any invocation delivering only one argument will be considered erroneous, and will abort the 
code's execution);
3.third, Python leaves your code for a moment and jumps into the function you want to 
invoke; of course, it takes your argument(s) too and passes it/them to the function;
4.fourth, the function executes its code, causes the desired effect 
(if any), evaluates the desired result(s) (if any) and finishes its task;
5.finally, Python returns to your code (to the place just after the invocation) 
and resumes its execution.
_____________________________________________________________________________________________________
The print() function
Three important questions have to be answered as soon as possible:
1. What is the effect the print() function causes?
The effect is very useful and very spectacular. The function:
takes its arguments (it may accept more than one argument and may also accept less 
than one argument)
converts them into human-readable form if needed (as you may suspect, strings don't require 
this action, as the string is already readable)
and sends the resulting data to the output device (usually the console); 
in other words, anything you put into the print() function will appear on your screen.
No wonder then, that from now on, you'll utilize print() very intensively to see the results of 
your operations and evaluations.
2. What arguments does print() expect?
Any. We'll show you soon that print() is able to operate with virtually all types of data offered 
by Python. Strings, numbers, characters, logical values, objects - any of these may be 
successfully passed to print()

3. What value does the print() function evaluate?
None. Its effect is enough - print() does not evaluate anything.
_____________________________________________________________________________________________________
Key takeaways
1. The print() function is a built-in function. It prints/outputs a specified message to the 
screen/consol window.
2. Built-in functions, contrary to user-defined functions, are always available and don't 
have to be imported. Python 3.7.1 comes with 69 built-in functions. You can find their 
full list provided in alphabetical order in the Python Standard Library.
3.To call a function (function invocation), you need to use the function name followed 
by parentheses. You can pass arguments into a function by placing them inside the 
parentheses. You must separate arguments with a comma, e.g., print("Hello,", "world!"). 
An "empty" print() function outputs an empty line to the screen.
Python strings are delimited with quotes, e.g., "I am a string", or 'I am a string, too'.
4. Python strings are delimited with quotes, e.g., "I am a string", or 'I am a string, too'.
5. Computer programs are collections of instructions. An instruction is a command to 
perform a specific task when executed, e.g., to print a certain message to the screen.
6. In Python strings the backslash (\) is a special character which announces that the 
next character has a different meaning, e.g., \n (the newline character) starts a new output line.
7. Positional arguments are the ones whose meaning is dictated by their position, e.g., the 
second argument is outputted after the first, the third is outputted after the second, etc.
8. Keyword arguments are the ones whose meaning is not dictated by their location, but 
by a special word (keyword) used to identify them.
9. The end and sep parameters can be used for formatting the output of the print() function. 
The sep parameter specifies the separator between the outputted arguments 
(e.g., print("H", "E", "L", "L", "O", sep="-"), whereas the end parameter specifies what to 
print at the end of the print statement.
_____________________________________________________________________________________________________
Literals - the data in itself
Now that you have a little knowledge of some of the powerful features offered by the print() function, 
it's time to learn about some new issues, and one important new term - the literal.
A literal is data whose values are determined by the literal itself.
As this is a difficult concept to understand, a good example may be helpful.
Take a look at the following set of digits
123
Can you guess what value it represents? Of course you can - it's one hundred twenty three.
But what about this:
c
Does it represent any value? Maybe. It can be the symbol of the speed of light, for example. 
It also can be the constant of integration. Or even the length of a hypotenuse in the sense of a 
Pythagorean theorem. There are many possibilities.
You cannot choose the right one without some additional knowledge.
And this is the clue: 123 is a literal, and c is not.
You use literals to encode data and to put them into your code. We're now going to show you 
some conventions you have to obey when using Python.
_____________________________________________________________________________________________________

Integers 
You may already know a little about how computers perform calculations on numbers. 
Perhaps you've heard of the binary system, and know that it's the system computers use for storing 
numbers, and that they can perform any operation upon them.
We won't explore the intricacies of positional numeral systems here, but we'll say that the 
numbers handled by modern computers are of two types:
integers, that is, those which are devoid of the fractional part;
and floating-point numbers (or simply floats), that contain (or are able to contain) the fractional part.
This definition is not entirely accurate, but quite sufficient for now. The distinction is very 
important, and the boundary between these two types of numbers is very strict. Both of these kinds of 
numbers differ significantly in how they're stored in a computer memory and in the range of acceptable 
values.
The characteristic of the numeric value which determines its kind, range, and application, is called the type.
If you encode a literal and place it inside Python code, the form of the literal determines the 
representation (type) Python will use to store it in the memory.
For now, let's leave the floating-point numbers aside (we'll come back to them soon) and consider the 
question of how Python recognizes integers.
The process is almost like how you would write them with a pencil on paper - it's simply a string of 
digits that make up the number. But there's a reservation - you must not interject any characters 
that are not digits inside the number.
Take, for example, the number eleven million one hundred and eleven thousand one hundred and eleven. 
If you took a pencil in your hand right now, you would write the number like this: 11,111,111, 
or like this: 11.111.111, or even like this: 11 111 111.
It's clear that this provision makes it easier to read, especially when the number consists of 
many digits. However, Python doesn't accept things like these. It's prohibited. What Python does 
allow, though, is the use of underscores in numeric literals.*
Therefore, you can write this number either like this: 11111111, or like that: 11_111_111.
NOTE   *Python 3.6 has introduced underscores in numeric literals, allowing for placing single 
underscores between digits and after base specifiers for improved readability. This feature is 
not available in older versions of Python.
And how do we code negative numbers in Python? As usual - by adding a minus. 
You can write: -11111111, or -11_111_111.
Positive numbers do not need to be preceded by the plus sign, but it's permissible, 
if you wish to do it. The following lines describe the same number: +11111111 and 11111111.
_____________________________________________________________________________________________________
Integers: octal and hexadecimal numbers
There are two additional conventions in Python that are unknown to the world of mathematics. 
The first allows us to use numbers in an octal representation.
If an integer number is preceded by an 0O or 0o prefix (zero-o), it will be treated as an octal value. 
This means that the number must contain digits taken from the [0..7] range only.
0o123 is an octal number with a (decimal) value equal to 83
The print() function does the conversion automatically. Try this:
print(0o123)
The second convention allows us to use hexadecimal numbers. Such numbers should be preceded by 
the prefix 0x or 0X (zero-x).
0x123 is a hexadecimal number with a (decimal) value equal to 291. The print() function can manage 
these values too. Try this:
print(0x123)
_____________________________________________________________________________________________________
Floats
Now it's time to talk about another type, which is designed to represent and to store the numbers 
that (as a mathematician would say) have a non-empty decimal fraction.
They are the numbers that have (or may have) a fractional part after the decimal point, and 
although such a definition is very poor, it's certainly sufficient for what we wish to discuss.
Whenever we use a term like two and a half or minus zero point four, we think of numbers which 
the computer considers floating-point numbers:
2.5
-0.4

Note: two and a half looks normal when you write it in a program, although if your native 
language prefers to use a comma instead of a point in the number, you should ensure that your 
number doesn't contain any commas at all.
Python will not accept that, or (in very rare but possible cases) may misunderstand your intentions, 
as the comma itself has its own reserved meaning in Python.
If you want to use just a value of two and a half, you should write it as shown above. Note once 
again - there is a point between 2 and 5 - not a comma.
As you can probably imagine, the value of zero point four could be written in Python as:
0.4
But don't forget this simple rule - you can omit zero when it is the only digit in front of or 
after the decimal point.
In essence, you can write the value 0.4 as:
.4
For example: the value of 4.0 could be written as:
4.
This will change neither its type nor its value.
_____________________________________________________________________________________________________
Ints vs. floats
The decimal point is essentially important in recognizing floating-point numbers in Python
Look at these two numbers:
4
4.0
You may think that they are exactly the same, but Python sees them in a completely different way.
4 is an integer number, whereas 4.0 is a floating-point number.
The point is what makes a float.
On the other hand, it's not only points that make a float. You can also use the letter e.
When you want to use any numbers that are very large or very small, you can use scientific notation.
Take, for example, the speed of light, expressed in meters per second. Written directly it 
would look like this: 300000000.
To avoid writing out so many zeros, physics textbooks use an abbreviated form, which you 
have probably already seen: 3 x 108.
It reads: three times ten to the power of eight.
In Python, the same effect is achieved in a slightly different way - take a look:
3E8
The letter E (you can also use the lower-case letter e - it comes from the word exponent) is a concise 
record of the phrase times ten to the power of.
Note:
the exponent (the value after the E) has to be an integer;
the base (the value in front of the E) may be an integer.
_____________________________________________________________________________________________________
Coding floats
Let's see how this convention is used to record numbers that are very small (in the sense of their 
absolute value, which is close to zero).
A physical constant called Planck's constant (and denoted as h), according to the textbooks, 
has the value of: 6.62607 x 10-34.
If you would like to use it in a program, you should write it this way:
6.62607E-34
Note: the fact that you've chosen one of the possible forms of coding float values doesn't mean 
that Python will present it the same way.
Python may sometimes choose different notation than you.
For example, let's say you've decided to use the following float literal:
0.0000000000000000000001
When you run this literal through Python:
print(0.0000000000000000000001)
this is the result:
1e-22
Python always chooses the more economical form of the number's presentation, and you should take 
this into consideration when creating literals.
_____________________________________________________________________________________________________
Strings
Strings are used when you need to process text (like names of all kinds, addresses, novels, etc.), 
not numbers.
You already know a bit about them, e.g., that strings need quotes the way floats need points.
This is a very typical string: "I am a string."
However, there is a catch. The catch is how to encode a quote inside a string which is already delimited by quotes.
Let's assume that we want to print a very simple message saying:
I like "Monty Python"
How do we do it without generating an error? There are two possible solutions.
The first is based on the concept we already know of the escape character, which you should remember 
is played by the backslash. The backslash can escape quotes too. A quote preceded by a backslash 
changes its meaning - it's not a delimiter, but just a quote. This will work as intended:
print("I like \"Monty Python\"")
Note: there are two escaped quotes inside the string - can you see them both?
The second solution may be a bit surprising. Python can use an apostrophe instead of a quote. 
Either of these characters may delimit strings, but you must be consistent
If you open a string with a quote, you have to close it with a quote.
If you start a string with an apostrophe, you have to end it with an apostrophe.
This example will work too:
print('I like "Monty Python"')
Note: you don't need to do any escaping here.
_____________________________________________________________________________________________________
Coding strings
Now, the next question is: how do you embed an apostrophe into a string placed between apostrophes?
You should already know the answer, or to be precise, two possible answers.
Try to print out a string containing the following message:
I'm Monty Python.
Do you know how to do it? Click Check below to see if you were right:
print('I\'m Monty Python.')
or 
print("I'm Monty Python.")
As you can see, the backslash is a very powerful tool - it can escape not only quotes, 
but also apostrophes.
We've shown it already, but we want to emphasize this phenomenon once more - a string 
can be empty - it may contain no characters at all.
An empty string still remains a string:
''
""
_____________________________________________________________________________________________________
Boolean values
To conclude with Python's literals, there are two additional ones.
They're not as obvious as any of the previous ones, as they're used to 
represent a very abstract value - truthfulness.
Each time you ask Python if one number is greater than another, the question results in the 
creation of some specific data - a Boolean value.
The name comes from George Boole (1815-1864), the author of the fundamental work, 
The Laws of Thought, which contains the definition of Boolean algebra - a part of algebra 
which makes use of only two distinct values: True and False, denoted as 1 and 0.
A programmer writes a program, and the program asks questions. Python executes the program, 
and provides the answers. The program must be able to react according to the received answers
Fortunately, computers know only two kinds of answers:
Yes, this is true;
No, this is false.
You'll never get a response like: I don't know or Probably yes, but I don't know for sure.
Python, then, is a binary reptile.
These two Boolean values have strict denotations in Python:
True
False
You cannot change anything - you have to take these symbols as they are, including case-sensitivity.
Challenge: What will be the output of the following snippet of code?
print(True > False)
print(True < False)
Run the code in the Sandbox to check. Can you explain the result?
_____________________________________________________________________________________________________
Key takeaways
1. Literals are notations for representing some fixed values in code. Python has various types of 
literals - for example, a literal can be a number (numeric literals, e.g., 123), or a string 
(string literals, e.g., "I am a literal.").
2. The binary system is a system of numbers that employs 2 as the base. Therefore, a 
binary number is made up of 0s and 1s only, e.g., 1010 is 10 in decimal.
Octal and hexadecimal numeration systems, similarly, employ 8 and 16 as their bases respectively. 
The hexadecimal system uses the decimal numbers and six extra letters.
3. Integers (or simply ints) are one of the numerical types supported by Python. 
They are numbers written without a fractional component, e.g., 256, or -1 (negative integers).
4. Floating-point numbers (or simply floats) are another one of the numerical types supported 
by Python. They are numbers that contain (or are able to contain) a fractional component, e.g., 1.27.
5. To encode an apostrophe or a quote inside a string you can either use the escape 
character, e.g., 'I\'m happy.', or open and close the string using an opposite set of symbols to 
the ones you wish to encode, e.g., "I'm happy." to encode an apostrophe, and 'He said "Python", 
not "typhoon"' to encode a (double) quote.
6. Boolean values are the two constant objects True and False used to represent truth values 
(in numeric contexts 1 is True, while 0 is False.

There is one more, special literal that is used in Python: the None literal. 
This literal is a so-called NoneType object, and it is used to represent the absence of a value. 
We'll tell you more about it soon.

What types of literals are the following two examples?
"Hello ", "007"
Answer is: They're both string literals

What types of literals are the following four examples?
"1.5", 2.0, 528, False
The first is a string, the second is a numerical literal (a float), the third is a numerical literal 
(an integer), and the fourth is a boolean literal.

What is the decimal value of the following binary number?
1011
It's 11, because (2**0) + (2**1) + (2**3) = 11
_____________________________________________________________________________________________________
Python as a calculator
Now, we're going to show you a completely new side of the print() function. You already know that 
the function is able to show you the values of the literals passed to it by arguments.
In fact, it can do something more. Take a look at the snippet:
print(2+2)
Retype the code in the editor and run it. Can you guess the output?
You should see the number four. Feel free to experiment with other operators.
Without taking this too seriously, you've just discovered that Python can be used as a calculator. 
Not a very handy one, and definitely not a pocket one, but a calculator nonetheless.
Taking it more seriously, we are now entering the province of operators and expressions.

Basix operators 
An operator is a symbol of the programming language, which is able to operate on the values.
For example, just as in arithmetic, the + (plus) sign is the operator which is able to add 
two numbers, giving the result of the addition.
Not all Python operators are as obvious as the plus sign, though, so let's go through some 
of the operators available in Python, and we'll explain which rules govern their use, 
and how to interpret the operations they perform.
We'll begin with the operators which are associated with the most widely 
recognizable arithmetic operations:
+, -, *, /, //, %, **
The order of their appearance is not accidental. We'll talk more about it once we've gone through them all.
Remember: Data and operators when connected together form expressions. The simplest expression is a literal itself.
_____________________________________________________________________________________________________